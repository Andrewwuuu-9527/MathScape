<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>奇异值分解(SVD) </title>
    <style>
        /* === CSS 变量定义 - 确保主题一致性 === */
        :root {
            --primary-color: #e67e22;
            --primary-dark: #d35400;
            --secondary-color: #ecf0f1;
            --text-color: #2c3e50;
            --background-color: #f9f9f9;
            --control-bg: #fdebd0;
            --header-gradient: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
        }

        /* === 基础样式重置 === */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        /* === 导航菜单样式 === */
        nav {
            background: #2c3e50;
            padding: 15px 0;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .nav-button {
            background: transparent;
            color: white;
            border: 2px solid #3498db;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .nav-button:hover {
            background: #3498db;
            transform: translateY(-2px);
        }

        .nav-button.active {
            background: #3498db;
            box-shadow: 0 2px 4px rgba(52, 152, 219, 0.3);
        }

        /* === 页面头部样式 === */
        header {
            text-align: center;
            background: var(--header-gradient);
            color: white;
            padding: 40px 30px;
            border-radius: 12px;
            margin-bottom: 35px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 2.8em;
            font-weight: 700;
        }

        .subtitle {
            font-size: 1.3em;
            opacity: 0.9;
            font-weight: 300;
        }

        /* === 可视化容器样式 === */
        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin: 25px 0;
        }

        @media (max-width: 968px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
        }

        .sketch-panel {
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            background: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            height: 500px;
            position: relative;
            overflow: hidden;
        }

        .sketch-panel h3 {
            text-align: center;
            padding: 15px;
            background: var(--primary-color);
            color: white;
            margin: 0;
            border-radius: 10px 10px 0 0;
        }

        /* === 控制面板样式 === */
        .controls {
            background: var(--control-bg);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .controls h3 {
            text-align: center;
            margin-bottom: 20px;
            color: var(--text-color);
            font-size: 1.5em;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 20px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.7);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .control-group h4 {
            margin-bottom: 15px;
            color: var(--primary-dark);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 5px;
        }

        .matrix-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .matrix-input {
            text-align: center;
        }

        .matrix-input label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-color);
        }

        .matrix-input input {
            width: 80px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            text-align: center;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .matrix-input input:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        .slider-container {
            margin: 15px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-color);
        }

        .slider-value {
            display: inline-block;
            min-width: 60px;
            text-align: right;
            font-weight: 600;
            color: var(--primary-dark);
        }

        input[type="range"] {
            width: 100%;
            margin: 8px 0;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            transition: background 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--primary-dark);
        }

        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            font-size: 16px;
            color: var(--text-color);
            cursor: pointer;
            transition: border-color 0.3s;
        }

        select:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        /* === 按钮样式 === */
        .button-group {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            min-width: 140px;
        }

        button:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(230, 126, 34, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #95a5a6;
        }

        button.secondary:hover {
            background: #7f8c8d;
        }

        /* === 说明区域样式 === */
        .explanation {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin: 25px 0;
        }

        .explanation h3 {
            color: var(--primary-dark);
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        .explanation p {
            margin-bottom: 15px;
        }

        .explanation ul, .explanation ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .explanation li {
            margin-bottom: 8px;
        }

        .math-equation {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid var(--primary-color);
            margin: 15px 0;
            text-align: center;
            font-size: 1.2em;
        }

        .info-panel {
            background: #fef5e7;
            border-left: 4px solid var(--primary-color);
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 6px 6px 0;
        }

        /* === 标签页样式 === */
        .tab-container {
            display: flex;
            justify-content: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tab {
            padding: 12px 24px;
            background: #bdc3c7;
            border: none;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            color: var(--text-color);
        }

        .tab.active {
            background: var(--primary-color);
            color: white;
        }

        .tab:hover:not(.active) {
            background: #95a5a6;
            color: white;
        }

        /* === 响应式设计 === */
        @media (max-width: 768px) {
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .matrix-controls {
                grid-template-columns: 1fr;
            }
            
            .nav-container {
                flex-direction: column;
                align-items: center;
            }
            
            .nav-button {
                width: 90%;
                text-align: center;
            }
            
            h1 {
                font-size: 2.2em;
            }
        }
    </style>
</head>
<body>
    <!-- 导航菜单 -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-button">特征值与特征向量</a>
            <a href="determinants.html" class="nav-button">行列式几何</a>
            <a href="svd.html" class="nav-button active">奇异值分解</a>
            <a href="linear_transformations.html" class="nav-button">线性变换</a>
            <a href="qr.html" class="nav-button">QR分解</a>
            <a href="lu.html" class="nav-button">LU分解</a>
            <a href="fourier.html" class="nav-button">傅里叶变换</a>
            <a href="gradient_descent.html" class="nav-button">梯度下降</a>
            <a href="probability.html" class="nav-button">概率分布</a>
            <a href="differential_equations.html" class="nav-button">微分方程</a>
        </div>
    </nav>

    <header>
        <h1>奇异值分解(SVD)</h1>
        <p class="subtitle">探索矩阵分解的几何意义与应用</p>
    </header>
    
    <main>
        <div class="tab-container">
            <button class="tab active" onclick="switchTab('decomposition')">分解过程</button>
            <button class="tab" onclick="switchTab('geometry')">几何解释</button>
            <button class="tab" onclick="switchTab('applications')">应用场景</button>
        </div>
        
        <div class="visualization-container">
            <div class="sketch-panel">
                <h3>单位圆与变换</h3>
                <div id="unit-circle-space"></div>
            </div>
            <div class="sketch-panel">
                <h3>SVD分解步骤</h3>
                <div id="svd-steps-space"></div>
            </div>
        </div>
        
        <div class="controls">
            <h3>矩阵参数控制</h3>
            
            <div class="control-grid">
                <div class="control-group">
                    <h4>矩阵 A</h4>
                    
                    <div class="matrix-controls">
                        <div class="matrix-input">
                            <label>a₁₁</label>
                            <input type="number" id="a11" value="2" step="0.1" onchange="updateMatrix()">
                        </div>
                        <div class="matrix-input">
                            <label>a₁₂</label>
                            <input type="number" id="a12" value="1" step="0.1" onchange="updateMatrix()">
                        </div>
                        <div class="matrix-input">
                            <label>a₂₁</label>
                            <input type="number" id="a21" value="1" step="0.1" onchange="updateMatrix()">
                        </div>
                        <div class="matrix-input">
                            <label>a₂₂</label>
                            <input type="number" id="a22" value="2" step="0.1" onchange="updateMatrix()">
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <label>矩阵范数缩放: 
                            <span class="slider-value" id="matrixScaleValue">1.00</span>
                        </label>
                        <input type="range" id="matrixScale" min="0.1" max="2.0" step="0.05" value="1.0" 
                               onchange="updateMatrixScale()">
                    </div>
                </div>
                
                <div class="control-group">
                    <h4>预设矩阵</h4>
                    
                    <div class="slider-container">
                        <label>选择预设: 
                            <select id="presetMatrix" onchange="applyPreset()">
                                <option value="identity">单位矩阵</option>
                                <option value="rotation">旋转矩阵</option>
                                <option value="scaling">缩放矩阵</option>
                                <option value="shear">剪切矩阵</option>
                                <option value="symmetric">对称矩阵</option>
                                <option value="custom">自定义</option>
                            </select>
                        </label>
                    </div>
                    
                    <div class="slider-container">
                        <label>旋转角度: 
                            <span class="slider-value" id="rotationValue">0</span>°
                        </label>
                        <input type="range" id="rotation" min="0" max="360" step="1" value="0" 
                               onchange="updateRotation()">
                    </div>
                    
                    <div class="slider-container">
                        <label>缩放因子: 
                            <span class="slider-value" id="scaleValue">1.00</span>
                        </label>
                        <input type="range" id="scale" min="0.1" max="3.0" step="0.1" value="1.0" 
                               onchange="updateScale()">
                    </div>
                </div>
            </div>
            
            <div class="info-panel">
                <strong>SVD分解信息:</strong>
                <span id="svdInfo">计算中...</span>
            </div>
            
            <div class="button-group">
                <button onclick="animateDecomposition()">播放分解动画</button>
                <button onclick="resetVisualization()" class="secondary">重置</button>
                <button onclick="toggleGrid()" class="secondary">切换网格</button>
                <button onclick="exportState()" class="secondary">导出状态</button>
            </div>
        </div>
        
        <div class="explanation">
            <div id="decompositionExplanation">
                <h3>奇异值分解(SVD)的原理</h3>
                <p>奇异值分解是线性代数中一种重要的矩阵分解方法，它将任意矩阵分解为三个特殊矩阵的乘积：</p>
                
                <div class="math-equation">
                    A = U Σ V<sup>T</sup>
                </div>
                
                <p><strong>其中：</strong></p>
                <ul>
                    <li><strong>U</strong>：左奇异向量矩阵，列向量正交</li>
                    <li><strong>Σ</strong>：奇异值矩阵，对角线元素为非负实数（奇异值）</li>
                    <li><strong>V<sup>T</sup></strong>：右奇异向量矩阵的转置，行向量正交</li>
                </ul>
                
                <p><strong>几何解释：</strong></p>
                <p>SVD分解可以理解为将线性变换分解为三个简单变换的复合：</p>
                <ol>
                    <li><strong>旋转/反射 (V<sup>T</sup>)</strong>：将输入空间旋转到标准位置</li>
                    <li><strong>缩放 (Σ)</strong>：沿坐标轴方向进行缩放</li>
                    <li><strong>旋转/反射 (U)</strong>：将结果旋转到输出空间的方向</li>
                </ol>
                
                <div class="info-panel">
                    <strong>关键性质：</strong> 奇异值总是非负的，并且按降序排列。奇异值的平方等于矩阵A<sup>T</sup>A的特征值。
                </div>
            </div>
            
            <div id="geometryExplanation" style="display:none">
                <h3>几何意义</h3>
                <p>奇异值分解提供了线性变换的几何直观理解：</p>
                
                <p><strong>单位圆的变换：</strong></p>
                <ul>
                    <li>任何线性变换都将单位圆映射为椭圆</li>
                    <li>奇异值表示椭圆的长轴和短轴长度</li>
                    <li>左奇异向量表示椭圆的方向</li>
                    <li>右奇异向量表示单位圆上映射到椭圆轴的向量方向</li>
                </ul>
                
                <p><strong>几何解释步骤：</strong></p>
                <ol>
                    <li>单位圆上的点首先通过V<sup>T</sup>旋转</li>
                    <li>然后通过Σ沿坐标轴缩放，形成椭圆</li>
                    <li>最后通过U旋转到最终位置</li>
                </ol>
                
                <div class="math-equation">
                    单位圆 → V<sup>T</sup> → Σ → U → 椭圆
                </div>
                
                <p>这个分解揭示了线性变换的本质：任何线性变换都可以分解为旋转、缩放、再旋转的组合。</p>
                
                <div class="info-panel">
                    <strong>提示：</strong> 请你观察单位圆如何通过三个步骤变换为椭圆，并注意奇异值如何决定椭圆的形状和大小。
                </div>
            </div>
            
            <div id="applicationsExplanation" style="display:none">
                <h3>应用场景</h3>
                <p>奇异值分解在科学计算和工程中具有广泛的应用：</p>
                
                <p><strong>1. 主成分分析(PCA)：</strong></p>
                <ul>
                    <li>SVD是PCA计算的核心</li>
                    <li>奇异向量对应主成分方向</li>
                    <li>奇异值对应各主成分的方差贡献</li>
                </ul>
                
                <p><strong>2. 数据压缩与降维：</strong></p>
                <ul>
                    <li>通过保留前k个奇异值实现数据压缩</li>
                    <li>在图像压缩中广泛应用（JPEG等）</li>
                    <li>减少数据存储和计算复杂度</li>
                </ul>
                
                <p><strong>3. 推荐系统：</strong></p>
                <ul>
                    <li>在协同过滤中用于矩阵补全</li>
                    <li>Netflix Prize竞赛中的关键技术</li>
                    <li>发现用户和物品的潜在特征</li>
                </ul>
                
                <p><strong>4. 数值线性代数：</strong></p>
                <ul>
                    <li>求解病态线性方程组</li>
                    <li>计算矩阵的伪逆</li>
                    <li>矩阵低秩近似</li>
                </ul>
                
                <p><strong>5. 信号处理：</strong></p>
                <ul>
                    <li>噪声过滤</li>
                    <li>信号分离</li>
                    <li>特征提取</li>
                </ul>
                
                <div class="info-panel">
                    <strong>实际意义：</strong> SVD之所以如此强大，是因为它适用于任何矩阵（包括非方阵），
                    并且提供了理解线性变换本质的最佳方式。
                </div>
            </div>
        </div>
    </main>

    <!-- 引入p5.js库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    
    <!-- SVD -->
    <script>
        // =============================================================================
        // 奇异值分解(SVD)
        // 作者: MathScape
        // 描述: 奇异值分解的几何解释
        // =============================================================================

        // =============================================
        // 模块一: 全局常量与变量定义
        // =============================================

        /** 可视化状态枚举 */
        const VisualizationState = {
            STATIC: 'static',
            ANIMATING: 'animating',
            INTERACTIVE: 'interactive'
        };

        /** 标签页类型枚举 */
        const TabType = {
            DECOMPOSITION: 'decomposition',
            GEOMETRY: 'geometry',
            APPLICATIONS: 'applications'
        };

        /** 预设矩阵类型枚举 */
        const PresetType = {
            IDENTITY: 'identity',
            ROTATION: 'rotation',
            SCALING: 'scaling',
            SHEAR: 'shear',
            SYMMETRIC: 'symmetric',
            CUSTOM: 'custom'
        };

        /** 可视化配置常量 */
        const VISUAL_CONFIG = {
            CANVAS_WIDTH: 400,
            CANVAS_HEIGHT: 400,
            ANIMATION_DURATION: 3000,    // 动画时长(ms)
            GRID_SIZE: 50,               // 网格大小
            UNIT_CIRCLE_POINTS: 100,     // 单位圆采样点数
            UNIT_CIRCLE_COLOR: [65, 105, 225, 150],   // 单位圆颜色
            ELLIPSE_COLOR: [220, 20, 60, 150],        // 椭圆颜色
            VECTOR_COLORS: [[30, 144, 255], [255, 140, 0]], // 向量颜色
            GRID_COLOR: [200, 200, 200, 50],          // 网格颜色
            STEP_COLORS: [
                [30, 144, 255, 100],    // 第一步颜色
                [50, 205, 50, 100],     // 第二步颜色  
                [255, 69, 0, 100]       // 第三步颜色
            ]
        };

        // =============================================
        // 模块二: 数学核心类
        // =============================================

        /** 二维向量类 */
        class Vector2D {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            /**
             * 向量加法
             * @param {Vector2D} other - 另一个向量
             * @returns {Vector2D} 结果向量
             */
            add(other) {
                return new Vector2D(this.x + other.x, this.y + other.y);
            }

            /**
             * 向量数乘
             * @param {number} scalar - 标量
             * @returns {Vector2D} 结果向量
             */
            multiply(scalar) {
                return new Vector2D(this.x * scalar, this.y * scalar);
            }

            /**
             * 向量长度
             * @returns {number} 向量模长
             */
            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            /**
             * 向量归一化
             * @returns {Vector2D} 归一化后的向量
             */
            normalize() {
                const mag = this.magnitude();
                if (mag === 0) return new Vector2D(0, 0);
                return new Vector2D(this.x / mag, this.y / mag);
            }

            /**
             * 点积
             * @param {Vector2D} other - 另一个向量
             * @returns {number} 点积结果
             */
            dot(other) {
                return this.x * other.x + this.y * other.y;
            }

            /**
             * 转换为数组
             * @returns {number[]} [x, y]数组
             */
            toArray() {
                return [this.x, this.y];
            }

            /**
             * 克隆向量
             * @returns {Vector2D} 新向量
             */
            clone() {
                return new Vector2D(this.x, this.y);
            }
        }

        /** 2x2矩阵类 */
        class Matrix2x2 {
            constructor(a11 = 1, a12 = 0, a21 = 0, a22 = 1) {
                this.a11 = a11;
                this.a12 = a12;
                this.a21 = a21;
                this.a22 = a22;
            }

            /**
             * 矩阵与向量乘法
             * @param {Vector2D} vector - 输入向量
             * @returns {Vector2D} 变换后的向量
             */
            multiplyVector(vector) {
                return new Vector2D(
                    this.a11 * vector.x + this.a12 * vector.y,
                    this.a21 * vector.x + this.a22 * vector.y
                );
            }

            /**
             * 矩阵与矩阵乘法
             * @param {Matrix2x2} other - 另一个矩阵
             * @returns {Matrix2x2} 乘积矩阵
             */
            multiplyMatrix(other) {
                return new Matrix2x2(
                    this.a11 * other.a11 + this.a12 * other.a21,
                    this.a11 * other.a12 + this.a12 * other.a22,
                    this.a21 * other.a11 + this.a22 * other.a21,
                    this.a21 * other.a12 + this.a22 * other.a22
                );
            }

            /**
             * 计算转置矩阵
             * @returns {Matrix2x2} 转置矩阵
             */
            transpose() {
                return new Matrix2x2(
                    this.a11, this.a21,
                    this.a12, this.a22
                );
            }

            /**
             * 计算行列式
             * @returns {number} 行列式值
             */
            determinant() {
                return this.a11 * this.a22 - this.a12 * this.a21;
            }

            /**
             * 创建旋转矩阵
             * @param {number} angle - 旋转角度(弧度)
             * @returns {Matrix2x2} 旋转矩阵
             */
            static rotation(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return new Matrix2x2(cos, -sin, sin, cos);
            }

            /**
             * 创建缩放矩阵
             * @param {number} sx - x方向缩放
             * @param {number} sy - y方向缩放
             * @returns {Matrix2x2} 缩放矩阵
             */
            static scaling(sx, sy) {
                return new Matrix2x2(sx, 0, 0, sy);
            }

            /**
             * 创建剪切矩阵
             * @param {number} k - 剪切因子
             * @returns {Matrix2x2} 剪切矩阵
             */
            static shearing(k) {
                return new Matrix2x2(1, k, 0, 1);
            }
        }

        /** SVD分解结果类 */
        class SVDResult {
            constructor(U, S, V) {
                this.U = U;  // 左奇异向量矩阵
                this.S = S;  // 奇异值矩阵 [σ1, σ2]
                this.V = V;  // 右奇异向量矩阵
            }

            /**
             * 获取Σ矩阵（缩放矩阵）
             * @returns {Matrix2x2} Σ矩阵
             */
            getSigmaMatrix() {
                return new Matrix2x2(this.S[0], 0, 0, this.S[1]);
            }

            /**
             * 重构原始矩阵
             * @returns {Matrix2x2} 重构的矩阵 A = U Σ V^T
             */
            reconstruct() {
                const sigma = this.getSigmaMatrix();
                const VT = this.V.transpose();
                return this.U.multiplyMatrix(sigma).multiplyMatrix(VT);
            }
        }

        // =============================================
        // 模块三: SVD计算算法
        // =============================================

        /** SVD计算器类 */
        class SVDCalculator {
            /**
             * 计算2x2矩阵的SVD分解
             * @param {Matrix2x2} A - 输入矩阵
             * @returns {SVDResult} SVD分解结果
             */
            static computeSVD2x2(A) {
                // 对于2x2矩阵，我们可以使用解析方法计算SVD
                const a = A.a11, b = A.a12, c = A.a21, d = A.a22;
                
                // 计算 A^T A
                const ata11 = a*a + c*c;
                const ata12 = a*b + c*d;
                const ata22 = b*b + d*d;
                
                // 计算 A^T A 的特征值和特征向量
                const trace = ata11 + ata22;
                const det = ata11 * ata22 - ata12 * ata12;
                
                // 特征值
                const discriminant = trace * trace - 4 * det;
                const lambda1 = (trace + Math.sqrt(discriminant)) / 2;
                const lambda2 = (trace - Math.sqrt(discriminant)) / 2;
                
                // 奇异值
                const sigma1 = Math.sqrt(lambda1);
                const sigma2 = Math.sqrt(lambda2);
                
                // 计算 V (A^T A 的特征向量)
                let v1, v2;
                
                if (Math.abs(ata12) > 1e-10) {
                    v1 = new Vector2D(ata12, lambda1 - ata11).normalize();
                    v2 = new Vector2D(ata12, lambda2 - ata11).normalize();
                } else {
                    // 如果 A^T A 是对角矩阵
                    v1 = new Vector2D(1, 0);
                    v2 = new Vector2D(0, 1);
                }
                
                // 确保特征向量正交
                if (Math.abs(v1.dot(v2)) > 1e-10) {
                    v2 = new Vector2D(-v1.y, v1.x);
                }
                
                const V = new Matrix2x2(v1.x, v2.x, v1.y, v2.y);
                
                // 计算 U
                const u1 = A.multiplyVector(new Vector2D(v1.x, v1.y)).multiply(1/sigma1);
                const u2 = A.multiplyVector(new Vector2D(v2.x, v2.y)).multiply(1/sigma2);
                
                const U = new Matrix2x2(u1.x, u2.x, u1.y, u2.y);
                
                return new SVDResult(U, [sigma1, sigma2], V);
            }

            /**
             * 验证SVD分解的正确性
             * @param {Matrix2x2} A - 原始矩阵
             * @param {SVDResult} svd - SVD分解结果
             * @returns {boolean} 分解是否正确
             */
            static verifySVD(A, svd) {
                const reconstructed = svd.reconstruct();
                return Math.abs(A.a11 - reconstructed.a11) < 1e-10 &&
                       Math.abs(A.a12 - reconstructed.a12) < 1e-10 &&
                       Math.abs(A.a21 - reconstructed.a21) < 1e-10 &&
                       Math.abs(A.a22 - reconstructed.a22) < 1e-10;
            }
        }

        // =============================================
        // 模块四: 可视化系统类 - 修复文字显示问题
        // =============================================

        /** SVD可视化系统 */
        class SVDVisualization {
            constructor() {
                // 变换矩阵
                this.matrix = new Matrix2x2(2, 1, 1, 2);
                
                // SVD分解结果
                this.svd = null;
                this.computeSVD();
                
                // 动画状态
                this.animationProgress = 0;
                this.animationStartTime = 0;
                this.state = VisualizationState.STATIC;
                
                // 显示设置
                this.showGrid = true;
                this.currentTab = TabType.DECOMPOSITION;
                
                // 单位圆点集
                this.unitCirclePoints = this.generateUnitCircle();
            }

            /**
             * 生成单位圆上的点
             * @returns {Vector2D[]} 单位圆点集
             */
            generateUnitCircle() {
                const points = [];
                const numPoints = VISUAL_CONFIG.UNIT_CIRCLE_POINTS;
                
                for (let i = 0; i < numPoints; i++) {
                    const angle = (2 * Math.PI * i) / numPoints;
                    points.push(new Vector2D(Math.cos(angle), Math.sin(angle)));
                }
                
                return points;
            }

            /**
             * 计算SVD分解
             */
            computeSVD() {
                this.svd = SVDCalculator.computeSVD2x2(this.matrix);
            }

            /**
             * 应用矩阵变换到点集
             * @param {Vector2D[]} points - 输入点集
             * @param {Matrix2x2} matrix - 变换矩阵
             * @returns {Vector2D[]} 变换后的点集
             */
            transformPoints(points, matrix) {
                return points.map(point => matrix.multiplyVector(point));
            }

            /**
             * 获取SVD分解步骤的点集
             * @returns {Object} 各步骤的点集
             */
            getDecompositionSteps() {
                const VT = this.svd.V.transpose();
                const sigma = this.svd.getSigmaMatrix();
                
                return {
                    step1: this.unitCirclePoints, // 原始单位圆
                    step2: this.transformPoints(this.unitCirclePoints, VT), // 经过V^T旋转
                    step3: this.transformPoints(this.unitCirclePoints, VT.multiplyMatrix(sigma)), // 经过Σ缩放
                    step4: this.transformPoints(this.unitCirclePoints, this.matrix) // 经过U旋转得到最终椭圆
                };
            }

            /**
             * 获取动画插值后的点集
             * @returns {Object} 动画中的点集
             */
            getAnimatedPoints() {
                if (this.state !== VisualizationState.ANIMATING) {
                    return this.getDecompositionSteps();
                }
                
                const steps = this.getDecompositionSteps();
                const progress = this.animationProgress;
                
                // 根据动画进度插值
                let currentPoints;
                if (progress < 0.33) {
                    // 第一步到第二步：V^T旋转
                    const t = progress / 0.33;
                    currentPoints = this.interpolatePoints(steps.step1, steps.step2, t);
                } else if (progress < 0.66) {
                    // 第二步到第三步：Σ缩放
                    const t = (progress - 0.33) / 0.33;
                    currentPoints = this.interpolatePoints(steps.step2, steps.step3, t);
                } else {
                    // 第三步到第四步：U旋转
                    const t = (progress - 0.66) / 0.34;
                    currentPoints = this.interpolatePoints(steps.step3, steps.step4, t);
                }
                
                return {
                    step1: steps.step1,
                    step2: steps.step2,
                    step3: steps.step3,
                    step4: steps.step4,
                    current: currentPoints
                };
            }

            /**
             * 点集线性插值
             * @param {Vector2D[]} points1 - 起点集
             * @param {Vector2D[]} points2 - 终点集
             * @param {number} t - 插值参数 [0,1]
             * @returns {Vector2D[]} 插值后的点集
             */
            interpolatePoints(points1, points2, t) {
                return points1.map((point, i) => {
                    return new Vector2D(
                        point.x + (points2[i].x - point.x) * t,
                        point.y + (points2[i].y - point.y) * t
                    );
                });
            }

            /**
             * 开始动画
             */
            startAnimation() {
                this.animationProgress = 0;
                this.animationStartTime = Date.now();
                this.state = VisualizationState.ANIMATING;
            }

            /**
             * 更新动画状态
             */
            updateAnimation() {
                if (this.state !== VisualizationState.ANIMATING) return;
                
                const elapsed = Date.now() - this.animationStartTime;
                this.animationProgress = Math.min(elapsed / VISUAL_CONFIG.ANIMATION_DURATION, 1);
                
                if (this.animationProgress >= 1) {
                    this.state = VisualizationState.STATIC;
                }
            }

            /**
             * 应用预设矩阵
             * @param {string} preset - 预设类型
             */
            applyPreset(preset) {
                switch (preset) {
                    case PresetType.IDENTITY:
                        this.matrix = new Matrix2x2(1, 0, 0, 1);
                        break;
                    case PresetType.ROTATION:
                        this.matrix = Matrix2x2.rotation(Math.PI / 6);
                        break;
                    case PresetType.SCALING:
                        this.matrix = Matrix2x2.scaling(2, 0.5);
                        break;
                    case PresetType.SHEAR:
                        this.matrix = Matrix2x2.shearing(0.8);
                        break;
                    case PresetType.SYMMETRIC:
                        this.matrix = new Matrix2x2(2, 1, 1, 2);
                        break;
                    case PresetType.CUSTOM:
                        // 保持当前矩阵
                        break;
                }
                
                this.computeSVD();
            }

            /**
             * 设置旋转矩阵
             * @param {number} degrees - 旋转角度(度)
             */
            setRotation(degrees) {
                const radians = degrees * Math.PI / 180;
                this.matrix = Matrix2x2.rotation(radians);
                this.computeSVD();
            }

            /**
             * 设置缩放矩阵
             * @param {number} scale - 缩放因子
             */
            setScale(scale) {
                this.matrix = Matrix2x2.scaling(scale, scale);
                this.computeSVD();
            }

            /**
             * 更新矩阵元素
             * @param {number} a11 - 元素11
             * @param {number} a12 - 元素12
             * @param {number} a21 - 元素21
             * @param {number} a22 - 元素22
             */
            updateMatrix(a11, a12, a21, a22) {
                this.matrix = new Matrix2x2(a11, a12, a21, a22);
                this.computeSVD();
            }
        }

        /** SVD可视化渲染器 - 修复文字显示问题 */
        class SVDRenderer {
            constructor() {
                this.system = new SVDVisualization();
            }

            /**
             * 绘制单位圆与变换
             * @param {p5} p - p5.js实例
             */
            drawUnitCircleSpace(p) {
                p.background(250);
                p.translate(VISUAL_CONFIG.CANVAS_WIDTH / 2, VISUAL_CONFIG.CANVAS_HEIGHT / 2);
                p.scale(1, -1); // 数学坐标系
                
                // 绘制网格
                if (this.system.showGrid) {
                    this.drawGrid(p);
                }
                
                // 绘制坐标轴
                this.drawAxes(p);
                
                // 绘制单位圆
                this.drawUnitCircle(p);
                
                // 绘制变换后的椭圆
                this.drawTransformedEllipse(p);
                
                // 绘制奇异向量
                this.drawSingularVectors(p);
                
                // 显示矩阵信息
                this.drawMatrixInfo(p);
            }

            /**
             * 绘制SVD分解步骤
             * @param {p5} p - p5.js实例
             */
            drawSVDStepsSpace(p) {
                // 更新动画状态
                this.system.updateAnimation();
                
                p.background(250);
                p.translate(VISUAL_CONFIG.CANVAS_WIDTH / 2, VISUAL_CONFIG.CANVAS_HEIGHT / 2);
                p.scale(1, -1); // 数学坐标系
                
                // 绘制网格
                if (this.system.showGrid) {
                    this.drawGrid(p);
                }
                
                // 绘制坐标轴
                this.drawAxes(p);
                
                // 根据动画状态绘制
                if (this.system.state === VisualizationState.ANIMATING) {
                    this.drawAnimatedDecomposition(p);
                } else {
                    this.drawStaticDecomposition(p);
                }
                
                // 显示SVD信息
                this.drawSVDInfo(p);
            }

            /**
             * 绘制网格
             * @param {p5} p - p5.js实例
             */
            drawGrid(p) {
                p.stroke(...VISUAL_CONFIG.GRID_COLOR);
                p.strokeWeight(1);
                
                const halfWidth = VISUAL_CONFIG.CANVAS_WIDTH / 2;
                const halfHeight = VISUAL_CONFIG.CANVAS_HEIGHT / 2;
                const gridSize = VISUAL_CONFIG.GRID_SIZE;
                
                for (let x = -halfWidth; x <= halfWidth; x += gridSize) {
                    p.line(x, -halfHeight, x, halfHeight);
                }
                for (let y = -halfHeight; y <= halfHeight; y += gridSize) {
                    p.line(-halfWidth, y, halfWidth, y);
                }
            }

            /**
             * 绘制坐标轴
             * @param {p5} p - p5.js实例
             */
            drawAxes(p) {
                p.stroke(0);
                p.strokeWeight(2);
                
                const halfWidth = VISUAL_CONFIG.CANVAS_WIDTH / 2;
                const halfHeight = VISUAL_CONFIG.CANVAS_HEIGHT / 2;
                
                // x轴
                p.line(-halfWidth, 0, halfWidth, 0);
                // y轴
                p.line(0, -halfHeight, 0, halfHeight);
                
                // 坐标轴箭头
                this.drawArrow(p, halfWidth - 10, 0, halfWidth, 0);
                this.drawArrow(p, 0, halfHeight - 10, 0, halfHeight);
                
                // 坐标轴标签
                p.push();
                p.scale(1, -1);
                p.fill(0);
                p.noStroke();
                p.textAlign(p.LEFT, p.TOP);
                p.text("x", halfWidth - 15, 5);
                p.text("y", 5, -halfHeight + 15);
                p.pop();
            }

            /**
             * 绘制箭头
             * @param {p5} p - p5.js实例
             */
            drawArrow(p, x1, y1, x2, y2) {
                p.line(x1, y1, x2, y2);
                
                const angle = p.atan2(y2 - y1, x2 - x1);
                const arrowSize = 8;
                
                p.push();
                p.translate(x2, y2);
                p.rotate(angle);
                p.line(0, 0, -arrowSize, arrowSize / 2);
                p.line(0, 0, -arrowSize, -arrowSize / 2);
                p.pop();
            }

            /**
             * 绘制单位圆
             * @param {p5} p - p5.js实例
             */
            drawUnitCircle(p) {
                const scale = VISUAL_CONFIG.GRID_SIZE;
                const points = this.system.unitCirclePoints.map(point => 
                    point.multiply(scale)
                );
                
                p.fill(...VISUAL_CONFIG.UNIT_CIRCLE_COLOR);
                p.stroke(30, 144, 255);
                p.strokeWeight(2);
                
                p.beginShape();
                points.forEach(point => p.vertex(point.x, point.y));
                p.endShape(p.CLOSE);
                
                // 标注 - 修复位置问题
                p.fill(30, 144, 255);
                p.noStroke();
                p.push();
                p.scale(1, -1);
                p.textAlign(p.CENTER, p.BOTTOM);
                p.text("单位圆", 0, -VISUAL_CONFIG.CANVAS_HEIGHT/2 + 40);
                p.pop();
            }

            /**
             * 绘制变换后的椭圆
             * @param {p5} p - p5.js实例
             */
            drawTransformedEllipse(p) {
                const scale = VISUAL_CONFIG.GRID_SIZE;
                const points = this.system.transformPoints(
                    this.system.unitCirclePoints, 
                    this.system.matrix
                ).map(point => point.multiply(scale));
                
                p.fill(...VISUAL_CONFIG.ELLIPSE_COLOR);
                p.stroke(220, 20, 60);
                p.strokeWeight(2);
                
                p.beginShape();
                points.forEach(point => p.vertex(point.x, point.y));
                p.endShape(p.CLOSE);
                
                // 标注 - 修复位置问题
                p.fill(220, 20, 60);
                p.noStroke();
                p.push();
                p.scale(1, -1);
                p.textAlign(p.CENTER, p.BOTTOM);
                p.text("变换后的椭圆", 0, -VISUAL_CONFIG.CANVAS_HEIGHT/2 + 70);
                p.pop();
            }

            /**
             * 绘制奇异向量
             * @param {p5} p - p5.js实例
             */
            drawSingularVectors(p) {
                const scale = VISUAL_CONFIG.GRID_SIZE;
                const svd = this.system.svd;
                
                // 绘制右奇异向量 (V)
                p.stroke(30, 144, 255);
                p.strokeWeight(3);
                this.drawVector(p, new Vector2D(0, 0), 
                    new Vector2D(svd.V.a11, svd.V.a21).multiply(scale * svd.S[0]));
                this.drawVector(p, new Vector2D(0, 0), 
                    new Vector2D(svd.V.a12, svd.V.a22).multiply(scale * svd.S[1]));
                
                // 绘制左奇异向量 (U)
                p.stroke(255, 140, 0);
                this.drawVector(p, new Vector2D(0, 0), 
                    new Vector2D(svd.U.a11, svd.U.a21).multiply(scale * svd.S[0]));
                this.drawVector(p, new Vector2D(0, 0), 
                    new Vector2D(svd.U.a12, svd.U.a22).multiply(scale * svd.S[1]));
                
                // 向量标签 - 修复位置问题
                p.fill(30, 144, 255);
                p.noStroke();
                p.push();
                p.scale(1, -1);
                p.textAlign(p.LEFT, p.TOP);
                p.text("右奇异向量", -VISUAL_CONFIG.CANVAS_WIDTH/2 + 20, -VISUAL_CONFIG.CANVAS_HEIGHT/2 + 100);
                p.fill(255, 140, 0);
                p.text("左奇异向量", -VISUAL_CONFIG.CANVAS_WIDTH/2 + 20, -VISUAL_CONFIG.CANVAS_HEIGHT/2 + 120);
                p.pop();
            }

            /**
             * 绘制向量
             * @param {p5} p - p5.js实例
             */
            drawVector(p, start, end) {
                p.line(start.x, start.y, end.x, end.y);
                this.drawArrow(p, start.x, start.y, end.x, end.y);
            }

            /**
             * 绘制静态分解步骤
             * @param {p5} p - p5.js实例
             */
            drawStaticDecomposition(p) {
                const scale = VISUAL_CONFIG.GRID_SIZE;
                const steps = this.system.getDecompositionSteps();
                
                // 绘制四个步骤 - 修复文字重叠问题
                const labelPositions = [
                    { x: -120, y: -170, align: p.CENTER, baseline: p.BOTTOM }, // 步骤1位置
                    { x: 120, y: -170, align: p.CENTER, baseline: p.BOTTOM },  // 步骤2位置
                    { x: -120, y: 170, align: p.CENTER, baseline: p.TOP },  // 步骤3位置
                    { x: 120, y: 170, align: p.CENTER, baseline: p.TOP }    // 步骤4位置
                ];
                
                this.drawStep(p, steps.step1, scale, VISUAL_CONFIG.STEP_COLORS[0], "1. 单位圆", labelPositions[0]);
                this.drawStep(p, steps.step2, scale, VISUAL_CONFIG.STEP_COLORS[1], "2. V^T 旋转", labelPositions[1]);
                this.drawStep(p, steps.step3, scale, VISUAL_CONFIG.STEP_COLORS[2], "3. Σ 缩放", labelPositions[2]);
                
                // 第四步稍微偏移以区分
                const step4Points = steps.step4.map(point => point.multiply(0.8)); // 缩小以避免重叠
                this.drawStep(p, step4Points, scale, VISUAL_CONFIG.ELLIPSE_COLOR, "4. U 旋转 → 椭圆", labelPositions[3]);
            }

            /**
             * 绘制动画分解
             * @param {p5} p - p5.js实例
             */
            drawAnimatedDecomposition(p) {
                const scale = VISUAL_CONFIG.GRID_SIZE;
                const steps = this.system.getAnimatedPoints();
                
                // 绘制前三个步骤（半透明）
                const labelPositions = [
                    { x: -120, y: -170, align: p.CENTER, baseline: p.BOTTOM }, // 步骤1位置
                    { x: 120, y: -170, align: p.CENTER, baseline: p.BOTTOM },  // 步骤2位置
                    { x: -120, y: 170, align: p.CENTER, baseline: p.TOP },   // 步骤3位置
                    { x: 120, y: 170, align: p.CENTER, baseline: p.TOP }     // 步骤4位置
                ];
                
                this.drawStep(p, steps.step1, scale, [...VISUAL_CONFIG.STEP_COLORS[0], 50], "1. 单位圆", labelPositions[0]);
                this.drawStep(p, steps.step2, scale, [...VISUAL_CONFIG.STEP_COLORS[1], 50], "2. V^T 旋转", labelPositions[1]);
                this.drawStep(p, steps.step3, scale, [...VISUAL_CONFIG.STEP_COLORS[2], 50], "3. Σ 缩放", labelPositions[2]);
                
                // 绘制第四步（半透明）- 修复动画中第四步消失的问题
                const step4Points = steps.step4.map(point => point.multiply(0.8));
                this.drawStep(p, step4Points, scale, [...VISUAL_CONFIG.ELLIPSE_COLOR, 50], "4. U 旋转 → 椭圆", labelPositions[3]);
                
                // 绘制当前动画步骤
                p.fill(...VISUAL_CONFIG.ELLIPSE_COLOR);
                p.stroke(220, 20, 60);
                p.strokeWeight(2);
                
                p.beginShape();
                steps.current.forEach(point => 
                    p.vertex(point.x * scale, point.y * scale)
                );
                p.endShape(p.CLOSE);
                
                // 标注当前步骤 - 修复位置问题
                let stepLabel = "";
                if (this.system.animationProgress < 0.33) {
                    stepLabel = "步骤 1 → 2: V^T 旋转";
                } else if (this.system.animationProgress < 0.66) {
                    stepLabel = "步骤 2 → 3: Σ 缩放";
                } else {
                    stepLabel = "步骤 3 → 4: U 旋转";
                }
                
                p.fill(220, 20, 60);
                p.noStroke();
                p.push();
                p.scale(1, -1);
                p.textAlign(p.CENTER, p.TOP);
                p.text(stepLabel, 0, VISUAL_CONFIG.CANVAS_HEIGHT/2 - 40);
                p.pop();
            }

            /**
             * 绘制分解步骤 - 修复文字定位
             * @param {p5} p - p5.js实例
             */
            drawStep(p, points, scale, color, label, labelPos) {
                const scaledPoints = points.map(point => point.multiply(scale));
                
                p.fill(...color);
                p.stroke(color[0], color[1], color[2]);
                p.strokeWeight(2);
                
                p.beginShape();
                scaledPoints.forEach(point => p.vertex(point.x, point.y));
                p.endShape(p.CLOSE);
                
                // 步骤标签 - 修复位置问题
                p.fill(color[0], color[1], color[2]);
                p.noStroke();
                p.push();
                p.scale(1, -1);
                p.textAlign(labelPos.align, labelPos.baseline);
                p.text(label, labelPos.x, labelPos.y);
                p.pop();
            }

            /**
             * 显示矩阵信息 - 修复位置问题
             * @param {p5} p - p5.js实例
             */
            drawMatrixInfo(p) {
                const matrix = this.system.matrix;
                
                p.push();
                p.scale(1, -1);
                p.fill(0);
                p.noStroke();
                p.textAlign(p.RIGHT, p.TOP);
                p.textSize(14);
                
                p.text(`矩阵 A = [${matrix.a11.toFixed(2)}, ${matrix.a12.toFixed(2)}]`, VISUAL_CONFIG.CANVAS_WIDTH/2 - 20, 20);
                p.text(`         [${matrix.a21.toFixed(2)}, ${matrix.a22.toFixed(2)}]`, VISUAL_CONFIG.CANVAS_WIDTH/2 - 20, 40);
                
                p.pop();
            }

            /**
             * 显示SVD信息 - 修复位置问题
             * @param {p5} p - p5.js实例
             */
            drawSVDInfo(p) {
                const svd = this.system.svd;
                
                p.push();
                p.scale(1, -1);
                p.fill(0);
                p.noStroke();
                p.textAlign(p.LEFT, p.TOP);
                p.textSize(12);
                
                // 调整SVD信息位置，避免与步骤标签重叠
                const infoY = VISUAL_CONFIG.CANVAS_HEIGHT/2 - 100;
                p.text(`奇异值: σ₁ = ${svd.S[0].toFixed(3)}, σ₂ = ${svd.S[1].toFixed(3)}`, -VISUAL_CONFIG.CANVAS_WIDTH/2 + 20, infoY);
                p.text(`条件数: ${(svd.S[0] / svd.S[1]).toFixed(3)}`, -VISUAL_CONFIG.CANVAS_WIDTH/2 + 20, infoY + 20);
                
                // 验证SVD正确性
                const isCorrect = SVDCalculator.verifySVD(this.system.matrix, svd);
                p.text(`SVD验证: ${isCorrect ? "正确" : "错误"}`, -VISUAL_CONFIG.CANVAS_WIDTH/2 + 20, infoY + 40);
                
                p.pop();
            }

            /**
             * 更新显示的SVD信息
             */
            updateSVDInfo() {
                const svd = this.system.svd;
                const matrix = this.system.matrix;
                const isCorrect = SVDCalculator.verifySVD(matrix, svd);
                
                const infoText = `奇异值: [${svd.S[0].toFixed(3)}, ${svd.S[1].toFixed(3)}] | 条件数: ${(svd.S[0] / svd.S[1]).toFixed(3)} | 验证: ${isCorrect ? "正确" : "错误"}`;
                document.getElementById('svdInfo').textContent = infoText;
            }
        }

        // =============================================
        // 模块五: 全局实例与初始化
        // =============================================

        /** 全局可视化渲染器实例 */
        let svdVisualizer;

        // =============================================
        // 模块六: p5.js 画布管理
        // =============================================

        /**
         * 单位圆画布的p5.js实例
         */
        let unitCircleSketch = function(p) {
            p.setup = function() {
                let canvas = p.createCanvas(400, 400);
                canvas.parent('unit-circle-space');
            };

            p.draw = function() {
                if (svdVisualizer) {
                    svdVisualizer.drawUnitCircleSpace(p);
                }
            };
        };

        /**
         * SVD步骤画布的p5.js实例
         */
        let svdStepsSketch = function(p) {
            p.setup = function() {
                let canvas = p.createCanvas(400, 400);
                canvas.parent('svd-steps-space');
            };

            p.draw = function() {
                if (svdVisualizer) {
                    svdVisualizer.drawSVDStepsSpace(p);
                }
            };
        };

        // =============================================
        // 模块七: 初始化函数
        // =============================================

        /**
         * 页面加载初始化
         */
        function initializePage() {
            svdVisualizer = new SVDRenderer();
            
            // 创建p5.js实例
            new p5(unitCircleSketch);
            new p5(svdStepsSketch);
            
            // 初始化显示
            updateMatrixInputs();
            svdVisualizer.updateSVDInfo();
        }

        // =============================================
        // 模块八: 用户界面控制函数
        // =============================================

        /**
         * 切换标签页
         * @param {string} tabName - 标签页名称
         */
        function switchTab(tabName) {
            // 更新标签激活状态
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // 更新可视化标签页
            if (svdVisualizer) {
                svdVisualizer.system.currentTab = tabName;
            }
            
            // 更新说明显示
            document.querySelectorAll('.explanation > div').forEach(div => {
                div.style.display = 'none';
            });
            document.getElementById(tabName + 'Explanation').style.display = 'block';
        }

        /**
         * 更新矩阵参数
         */
        function updateMatrix() {
            if (!svdVisualizer) return;
            
            const a11 = parseFloat(document.getElementById('a11').value);
            const a12 = parseFloat(document.getElementById('a12').value);
            const a21 = parseFloat(document.getElementById('a21').value);
            const a22 = parseFloat(document.getElementById('a22').value);
            
            svdVisualizer.system.updateMatrix(a11, a12, a21, a22);
            svdVisualizer.updateSVDInfo();
        }

        /**
         * 更新矩阵缩放
         */
        function updateMatrixScale() {
            const scale = parseFloat(document.getElementById('matrixScale').value);
            document.getElementById('matrixScaleValue').textContent = scale.toFixed(2);
            
            // 这里可以添加矩阵缩放逻辑
        }

        /**
         * 应用预设矩阵
         */
        function applyPreset() {
            if (!svdVisualizer) return;
            
            const preset = document.getElementById('presetMatrix').value;
            svdVisualizer.system.applyPreset(preset);
            svdVisualizer.updateSVDInfo();
            
            // 更新矩阵输入框显示
            updateMatrixInputs();
        }

        /**
         * 更新矩阵输入框显示
         */
        function updateMatrixInputs() {
            if (!svdVisualizer) return;
            
            const matrix = svdVisualizer.system.matrix;
            document.getElementById('a11').value = matrix.a11;
            document.getElementById('a12').value = matrix.a12;
            document.getElementById('a21').value = matrix.a21;
            document.getElementById('a22').value = matrix.a22;
        }

        /**
         * 更新旋转角度
         */
        function updateRotation() {
            const degrees = parseInt(document.getElementById('rotation').value);
            document.getElementById('rotationValue').textContent = degrees;
            
            if (svdVisualizer) {
                svdVisualizer.system.setRotation(degrees);
                svdVisualizer.updateSVDInfo();
                updateMatrixInputs();
            }
        }

        /**
         * 更新缩放因子
         */
        function updateScale() {
            const scale = parseFloat(document.getElementById('scale').value);
            document.getElementById('scaleValue').textContent = scale.toFixed(2);
            
            if (svdVisualizer) {
                svdVisualizer.system.setScale(scale);
                svdVisualizer.updateSVDInfo();
                updateMatrixInputs();
            }
        }

        /**
         * 播放分解动画
         */
        function animateDecomposition() {
            if (svdVisualizer) {
                svdVisualizer.system.startAnimation();
            }
        }

        /**
         * 重置可视化
         */
        function resetVisualization() {
            if (svdVisualizer) {
                svdVisualizer.system.updateMatrix(2, 1, 1, 2);
                svdVisualizer.updateSVDInfo();
                updateMatrixInputs();
            }
        }

        /**
         * 切换网格显示
         */
        function toggleGrid() {
            if (svdVisualizer) {
                svdVisualizer.system.showGrid = !svdVisualizer.system.showGrid;
            }
        }

        /**
         * 导出当前状态
         */
        function exportState() {
            if (!svdVisualizer) return;
            
            const state = {
                matrix: svdVisualizer.system.matrix,
                svd: svdVisualizer.system.svd,
                timestamp: new Date().toISOString()
            };
            
            console.log('导出状态:', state);
            alert('状态已导出到控制台，奇异值: ' + state.svd.S.map(s => s.toFixed(3)).join(', '));
        }

        // 页面加载完成后初始化
        window.addEventListener('DOMContentLoaded', initializePage);
    </script>
</body>
</html>